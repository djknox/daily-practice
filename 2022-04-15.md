## Daily Practice
### Friday, April 15th, 2022
---


# [The Docker Tutorial](https://laracasts.com/series/the-docker-tutorial)  


## [What is Docker](https://laracasts.com/series/the-docker-tutorial/episodes/1)  

Docker is a software platform that uses containers to build, share, and run apps.  

A Container is a lightweight VM - a packaged, isolated unit consisting of software needed for running apps.  

Running a container: `docker run {container-name}`  
```
docker run hello-world
```

List all running containers:  
```
docker ps
```

List all images:
```
docker image list
```



## [Create a Simple Dockerfile](https://laracasts.com/series/the-docker-tutorial/episodes/2) 

Image - template  
Container - instance of that template  

[Docker docs: `Dockerfile`](https://docs.docker.com/engine/reference/builder/)  
- text document that contains all the commands to assemble an image  

Building an image: `docker build {path/to/directory}`  
```
docker build .
```
- Docker looks for a `Dockerfile` in the specified directory and creates it  


```
// base image
FROM node:latest

// the directory to be in
WORKDIR /home/server

// running commands
RUN npm install -g json-server

// copying files/directories
COPY db.json /home/server/db.json
COPY alt.json /home/server/alt.json

// set the network port(s) the container listens on
EXPOSE 3000

// configure the container to run as an executable
ENTRYPOINT ["json-server", "db.json", "--host", "0.0.0.0"]

// provide defaults for an executing container
// can only be one/only the last CMD will take effect
CMD ["db.json"]
```

___exec_ form vs. _shell_ form:__  

_exec_ form:  
```
ENTRYPOINT ["executable", "param1", "param2"]
```
- must use double-quotes
- does not invoke a command shell

_shell_ form:  
```
ENTRYPOINT command param1 param2
```
- executes in `/bin/sh -c`
- uses shell processing



## [Setting Up Nginx](https://laracasts.com/series/the-docker-tutorial/episodes/3)  

`Dockerfile`:  
```
// base on stable-alpine release of nginx
FROM nginx:stable-alpine  

// create variables
ENV NGINXUSER=laravel
ENV NGINXGROUP=laravel

// create the folder that site source will be attached to
RUN mkdir -p /var/www/html/public

// pull in config file
ADD nginx/default.conf /etc/nginx/conf.d/default.conf

// edit the config file to adjust which user the process runs on
// (searches for 'user www-data' and replaces with 'user laravel')
RUN sed -i "s/user www-data/user ${NGINXUSER}/g" /etc/nginx/nginx.conf

// make the 'laravel' user
// attach it to the 'laravel' group
// attach it to the alpine linux shell
RUN adduser -g ${NGINXGROUP} -s /bin/sh -D ${NGINXUSER}
```

`nginx/default.conf`:  
```
server {
    listen 80;
    index index.php index.html;
    server_name _;
    root /var/www/html/public;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }
}
```

Build the Dockerfile into a usable image:  
```
docker build --no-cache -t laravel-nginx .
```
- `-t` tags the image with the name `laravel-nginx`  

Run the image as a container:  
```
docker run --rm -p 80:80 laravel-nginx
```
- `-p 80:80` maps port 80 to port 80 (host to container)  


__Volumes__  
- preferred mechanism for persisting data generated by/used by Docker containers  
- virtual mounted file systems that connect files and directories from the host machine to those in specific container(s)  
- data is modifiable in real time (updates in host machine will immediately update in container and vise versa)

Running a container with a volume:  
```
docker run --rm -p 80:80 -v /Users/DJKnox/code/laravel-docker/public:/var/www/html/public laravel-nginx
```
- `-v /Users/DJKnox/code/laravel-docker/public:/var/www/html/public`
   * maps host machine directory to directory in container  



## [Docker Compose and MySQL](https://laracasts.com/series/the-docker-tutorial/episodes/4)  

To run a Laravel app, also need containers for:  
- PHP
- MySQL
- Composer
- npm
- Redis
- etc.

[Docker docs: Overview of Docker Compose](https://docs.docker.com/compose/)  
__Compose__ is a tool used for defining and managing multi-container applications  
- uses a YAML file (`docker-compose.yml`) for specifying containers needed
- commands to build, run, manage containers

`docker-compose.yml`:  
```
// define a version
version: '3.8'

// list of services, each being a separate container (with its own image, exposed ports, volumes, etc.)
services:
    nginx:
        build:
            context: .
            dockerfile: nginx.dockerfile
        ports:
            - 80:80
        volumes:
            - ./code:/var/www/html/public
        depends_on:
            - mysql
    mysql:
        image: mysql:5.7
        ports:
            - 3306:3306
        environment:
            MYSQL_DATABASE: laravel
            MYSQL_USER: laravel
            MYSQL_PASSWORD: secret
            MYSQL_ROOT_PASSWORD: secret
        volumes:
            - ./mysql:/var/lib/mysql
```

Run `docker-compose.yml`:  
```
docker-compose up
```
- goes through each of the `services` headings
- pulls down/builds any images
- provisions containers with ports, volumes, etc.

List all containers that are related to the `docker-compose` file  
```
docker-compose ps
```

Specify containers to bring up based on their name in `services`:  
```
docker-compose up nginx
```
- if the container has anything listed in `depends_on`, then those containers will also be created



## [A PHP Container](https://laracasts.com/series/the-docker-tutorial/episodes/5) 

`docker-compose.yml`:  
```
// define a version
version: '3.8'

// list of services, each being a separate container (with its own image, exposed ports, volumes, etc.)
services:
    nginx:
        build:
            context: .
            dockerfile: nginx.dockerfile
        ports:
            - 80:80
        volumes:
            - ./code:/var/www/html/public
        depends_on:
            - mysql
            - php
    mysql:
        image: mysql:5.7
        ports:
            - 3306:3306
        environment:
            MYSQL_DATABASE: laravel
            MYSQL_USER: laravel
            MYSQL_PASSWORD: secret
            MYSQL_ROOT_PASSWORD: secret
        volumes:
            - ./mysql:/var/lib/mysql
    php:
        build:
            context: .
            dockerfile: php.dockerfile
        volumes:
            - ./code:/var/www/html/public
```

`php.dockerfile`:  
```
// base image
FROM php:8-from-alpine

// create variables
ENV PHPUSER=laravel
ENV PHPGROUP=laravel

// make the 'laravel' user
// attach it to the 'laravel' group
// attach it to the alpine linux shell
RUN adduser -g ${PHPGROUP} -s /bin/sh -D ${PHPUSER}

// edit the config file to adjust which user the process runs on
// (searches for 'user = www-data' and replaces with 'user = laravel')
RUN sed -i "s/user = www-data/user = ${PHPUSER}/g" /usr/local/etc/php-fpm.d/www.conf

// edit the config file to adjust which group the process runs on
// (searches for 'group = www-data' and replaces with 'group = laravel')
RUN sed -i "s/group = www-data/group = ${PHPGROUP}/g" /usr/local/etc/php-fpm.d/www.conf

// create application folder
RUN mkdir -p /var/www/html/public

// install PHP extensions (pdo and pdo_mysql)
RUN docker-php-ext-install pdo pdo_mysql

// modify default command that container runs when spinning up
CMD ["php-fpm", "-y", "/usr/local/etc/php-fpm.conf", "-R"]
```

`nginx/default.conf`:  
```
server {
    listen 80;
    index index.php index.html;
    server_name _;
    root /var/www/html/public;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}
```
- `fastcgi_pass php:9000;`
   * with containers that are connected via Compose, it is possible to reference a container by their `services` name (in this example, exposing the port `9000` on the `php` container)  

Last step is to create an `index.php` in the mapped volume directory:  
```
mkdir src/public
touch index.php
```

Running everything:  
```
docker-compose up --build
```
- `index.php` will be served at `localhost`  



## [Use Composer With Docker](https://laracasts.com/series/the-docker-tutorial/episodes/6)  

`docker-compose.yml`:  
```
// define a version
version: '3.8'

// list of services, each being a separate container (with its own image, exposed ports, volumes, etc.)
services:
    nginx:
        build:
            context: .
            dockerfile: nginx.dockerfile
        ports:
            - 80:80
        volumes:
            - ./code:/var/www/html/public
        depends_on:
            - mysql
            - php
    mysql:
        image: mysql:5.7
        ports:
            - 3306:3306
        environment:
            MYSQL_DATABASE: laravel
            MYSQL_USER: laravel
            MYSQL_PASSWORD: secret
            MYSQL_ROOT_PASSWORD: secret
        volumes:
            - ./mysql:/var/lib/mysql
    php:
        build:
            context: .
            dockerfile: php.dockerfile
        volumes:
            - ./code:/var/www/html/public
    composer:
        build:
            context: .
            dockerfile: composer.dockerfile
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
```
- `working_dir` defines where Composer will execute
    * by default, Composer will run in its home directory on the host, `working_dir` tells it to run in the mapped volume

`composer.dockerfile`:  
```
// base image
FROM composer:2

// create variables
ENV COMPOSERUSER=laravel
ENV COMPOSERGROUP=laravel

// make the 'laravel' user
// attach it to the 'laravel' group
// attach it to the alpine linux shell
RUN adduser -g ${COMPOSERGROUP} -s /bin/sh -D ${COMPOSERUSER}
```

Build `composer` image:  
```
docker-compose build composer
```

Running `composer` commands:
```
docker-compose run --rm composer create-project laravel/laravel .
```
- `docker-compose run`: run a command on a container
- `--rm`: destroys the container after running

Another example:  
```
docker-compose run --rm composer dump-autoload
```



## [Running Artisan and NPM](https://laracasts.com/series/the-docker-tutorial/episodes/7)  

### NPM

`docker-compose.yml`:  
```
// define a version
version: '3.8'

// list of services, each being a separate container (with its own image, exposed ports, volumes, etc.)
services:
    nginx:
        build:
            context: .
            dockerfile: nginx.dockerfile
        ports:
            - 80:80
        volumes:
            - ./code:/var/www/html/public
        depends_on:
            - mysql
            - php
    mysql:
        image: mysql:5.7
        ports:
            - 3306:3306
        environment:
            MYSQL_DATABASE: laravel
            MYSQL_USER: laravel
            MYSQL_PASSWORD: secret
            MYSQL_ROOT_PASSWORD: secret
        volumes:
            - ./mysql:/var/lib/mysql
    php:
        build:
            context: .
            dockerfile: php.dockerfile
        volumes:
            - ./code:/var/www/html/public
    composer:
        build:
            context: .
            dockerfile: composer.dockerfile
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
    npm:
        image: node:current-alpine
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
        entrypoint: ["npm"]
```
- because Node does not execute `npm` by default (unlike Composer and `composer`), need to add it to `entrypoint`

Running `npm` commands:
```
docker-compose run --rm npm install
```
- `docker-compose run`: run a command on a container
- `--rm`: destroys the container after running  

Another example:
```
docker-compose run --rm npm run dev
```


### Artisan

`docker-compose.yml`:  
```
// define a version
version: '3.8'

// list of services, each being a separate container (with its own image, exposed ports, volumes, etc.)
services:
    nginx:
        build:
            context: .
            dockerfile: nginx.dockerfile
        ports:
            - 80:80
        volumes:
            - ./code:/var/www/html/public
        depends_on:
            - mysql
            - php
    mysql:
        image: mysql:5.7
        ports:
            - 3306:3306
        environment:
            MYSQL_DATABASE: laravel
            MYSQL_USER: laravel
            MYSQL_PASSWORD: secret
            MYSQL_ROOT_PASSWORD: secret
        volumes:
            - ./mysql:/var/lib/mysql
    php:
        build:
            context: .
            dockerfile: php.dockerfile
        volumes:
            - ./code:/var/www/html/public
    composer:
        build:
            context: .
            dockerfile: composer.dockerfile
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
    npm:
        image: node:current-alpine
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
        entrypoint: ["npm"]
    artisan:
        build:
            context: .
            dockerfile: php.dockerfile
        volumes:
            - ./code:/var/www/html
        working_dir: /var/www/html
        depends_on:
            - mysql
        entrypoint: ["php", "/var/www/html/artisan"]
```

Configure environment variables in Laravel's `.env` that were configured in `docker-compose.yml`:  
```
DB_CONNECTION=mysql
DB_HOST=mysql
DB_PORT=3306
DB_DATABASE=laravel
DB_USERNAME=laravel
DB_PASSWORD=secret
```


Running `artisan` commands:
```
docker-compose run --rm artisan migrate
```
- `docker-compose run`: run a command on a container
- `--rm`: destroys the container after running  

Another example:
```
docker-compose run --rm artisan tinker
```



## [Packaging for Distribution](https://laracasts.com/series/the-docker-tutorial/episodes/8)  

[Docker Docs: Use Compose in production](https://docs.docker.com/compose/production/)  

Create a separate `docker-compose` file for production:  
```
touch docker-compose.prod.yml
```

`docker-compose.prod.yml`:  
```
version: '3.8'

services:
  nginx:
    build:
      context: .
      dockerfile: nginx.prod.dockerfile
    ports:
      - 80:80
      - 443:443
    depends_on: 
      - mysql
      - php
      - assets
  php:
    build:
      context: .
      dockerfile: php.prod.dockerfile
  assets:
    image: node:current-alpine
    volumes:
      - ./src:/var/www/html
    command: ["/bin/sh", "-c", "npm install && npm run production"]
    working_dir: /var/www/html
```
- `assets` service deals with compiling/minifying assets
   * `command` overrides the default command that the container runs
      - unlike `ENTRYPOINT`, this runs without input from the host machine
      - runs each time `docker-compose up` is ran


`nginx.prod.dockerfile`:  
```
FROM nginx:stable-alpine

ENV NGINXUSER=laravel
ENV NGINXGROUP=laravel

RUN mkdir -p /var/www/html/public

ADD nginx/default.prod.conf /etc/nginx/conf.d/default.conf
ADD nginx/laravel-docker.test.pem /etc/nginx/certs/laravel-docker.test.pem
ADD nginx/laravel-docker.test-key.pem /etc/nginx/certs/laravel-docker.test-key.pem


RUN sed -i "s/user www-data/user ${NGINXUSER}/g" /etc/nginx/nginx.conf

RUN adduser -g ${NGINXGROUP} -s /bin/sh -D ${NGINXUSER}
```


`nginx/default.prod.conf`:  
```
server {
    listen 80;
    index index.php index.html;
    server_name laravel-docker.test;
    root /var/www/html/public;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }
}

server {
    listen 443 ssl;
    index index.php index.html;
    server_name laravel-docker.test;
    root /var/www/html/public;

    location / {
        try_files $uri $uri/ /index.php?$query_string;
    }

    location ~ \.php$ {
        try_files $uri =404;
        fastcgi_split_path_info ^(.+\.php)(/.+)$;
        fastcgi_pass php:9000;
        fastcgi_index index.php;
        include fastcgi_params;
        fastcgi_param SCRIPT_FILENAME $document_root$fastcgi_script_name;
        fastcgi_param PATH_INFO $fastcgi_path_info;
    }

    ssl_certificate /path/to/certificate.pem;
    ssl_certificate_key /path/to/certificate-key.pem;
}
```


`php.prod.dockerfile`:  
```
FROM php:8-fpm-alpine

ENV PHPGROUP=laravel
ENV PHPUSER=laravel

RUN adduser -g ${PHPGROUP} -s /bin/sh -D ${PHPUSER}

RUN sed -i "s/user = www-data/user = ${PHPUSER}/g" /usr/local/etc/php-fpm.d/www.conf
RUN sed -i "s/group = www-data/group = ${PHPGROUP}/g" /usr/local/etc/php-fpm.d/www.conf

RUN mkdir -p /var/www/html/public

RUN docker-php-ext-install pdo pdo_mysql opcache

ADD opcache.ini /usr/local/etc/php/conf.d/opcache.ini

CMD ["php-fpm", "-y", "/usr/local/etc/php-fpm.conf", "-R"]
```


`opcache.ini`:  
```
[opcache]
opcache.enable=1
; 0 means it will check on every request
; 0 is irrelevant if opcache.validate_timestamps=0 which is desirable in production
opcache.revalidate_freq=0
opcache.validate_timestamps=1
opcache.max_accelerated_files=10000
opcache.memory_consumption=192
opcache.max_wasted_percentage=10
opcache.interned_strings_buffer=16
opcache.fast_shutdown=1
```


Differentiating between local and production environments:  
```
docker-compose -f docker-compose.yml -f docker-compose.prod.yml up --build nginx
```
- `-f`: specifies a file to parse and use
